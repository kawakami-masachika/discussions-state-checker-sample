name: Check Stale Discussions

on:
  schedule:
    # æ¯æ—¥åˆå‰9æ™‚ï¼ˆJSTï¼‰ã«å®Ÿè¡Œï¼ˆUTC 0æ™‚ï¼‰
    - cron: '0 0 * * *'
  workflow_dispatch: # æ‰‹å‹•å®Ÿè¡Œã‚‚å¯èƒ½

jobs:
  check-discussions:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Check stale discussions
      uses: actions/github-script@v7
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const { owner, repo } = context.repo;

          // è¨­å®š
          const TARGET_LABELS = ['help wanted', 'question']; // ãƒã‚§ãƒƒã‚¯å¯¾è±¡ã®ãƒ©ãƒ™ãƒ«
          const DAYS_THRESHOLD = 7; // 7æ—¥ä»¥ä¸Šå¤ã„ã‚‚ã®
          const SLACK_WEBHOOK_URL = process.env.SLACK_WEBHOOK_URL;

          // ç¾åœ¨æ™‚åˆ»ã‹ã‚‰7æ—¥å‰ã®æ—¥æ™‚ã‚’è¨ˆç®—
          const thresholdDate = new Date();
          thresholdDate.setDate(thresholdDate.getDate() - DAYS_THRESHOLD);

          try {
            // Discussionsã‚’å–å¾—ï¼ˆGraphQL APIã‚’ä½¿ç”¨ï¼‰
            const query = `
              query($owner: String!, $repo: String!, $after: String) {
                repository(owner: $owner, name: $repo) {
                  discussions(first: 100, after: $after, states: OPEN) {
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      id
                      title
                      url
                      createdAt
                      comments(first: 1) {
                        totalCount
                      }
                      labels(first: 10) {
                        nodes {
                          name
                        }
                      }
                    }
                  }
                }
              }
            `;

            let allDiscussions = [];
            let hasNextPage = true;
            let after = null;

            // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã§å…¨Discussionsã‚’å–å¾—
            while (hasNextPage) {
              const result = await github.graphql(query, {
                owner,
                repo,
                after
              });

              allDiscussions = allDiscussions.concat(result.repository.discussions.nodes);
              hasNextPage = result.repository.discussions.pageInfo.hasNextPage;
              after = result.repository.discussions.pageInfo.endCursor;
            }

            // æ¡ä»¶ã«åˆè‡´ã™ã‚‹Discussionsã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
            const staleDiscussions = allDiscussions.filter(discussion => {
              const createdAt = new Date(discussion.createdAt);
              const hasTargetLabel = discussion.labels.nodes.some(label => 
                TARGET_LABELS.includes(label.name)
              );
              const hasNoComments = discussion.comments.totalCount === 0;
              const isOlderThanThreshold = createdAt < thresholdDate;

              return hasTargetLabel && hasNoComments && isOlderThanThreshold;
            });

            console.log(`Found ${staleDiscussions.length} stale discussions`);

            // Slacké€šçŸ¥ã®æº–å‚™
            if (staleDiscussions.length > 0 && SLACK_WEBHOOK_URL) {
              const discussionList = staleDiscussions.map(discussion => {
                const daysAgo = Math.floor((new Date() - new Date(discussion.createdAt)) / (1000 * 60 * 60 * 24));
                return `â€¢ <${discussion.url}|${discussion.title}> (${daysAgo}æ—¥å‰ã«ä½œæˆ)`;
              }).join('\n');

              const slackMessage = {
                text: "æœªå›ç­”ã®DiscussionsãŒã‚ã‚Šã¾ã™",
                blocks: [
                  {
                    type: "header",
                    text: {
                      type: "plain_text",
                      text: "ğŸ”” æœªå›ç­”ã®Discussionsãƒã‚§ãƒƒã‚¯"
                    }
                  },
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: `${staleDiscussions.length}ä»¶ã®æœªå›ç­”DiscussionsãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸï¼š\n\n${discussionList}`
                    }
                  },
                  {
                    type: "context",
                    elements: [
                      {
                        type: "mrkdwn",
                        text: `æ¡ä»¶: ${TARGET_LABELS.join(', ')}ãƒ©ãƒ™ãƒ« | ${DAYS_THRESHOLD}æ—¥ä»¥ä¸ŠçµŒé | ã‚³ãƒ¡ãƒ³ãƒˆ0ä»¶`
                      }
                    ]
                  }
                ]
              };
              
              // Slackã«é€šçŸ¥ã‚’é€ä¿¡
              const response = await fetch(SLACK_WEBHOOK_URL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(slackMessage)
              });
              
              if (response.ok) {
                console.log('Slack notification sent successfully');
              } else {
                console.error('Failed to send Slack notification:', response.statusText);
              }
            } else if (staleDiscussions.length === 0) {
              console.log('No stale discussions found');
            } else {
              console.log('Slack webhook URL not configured');
            }
            
          } catch (error) {
            console.error('Error checking discussions:', error);
            
            // ã‚¨ãƒ©ãƒ¼æ™‚ã®Slacké€šçŸ¥
            if (SLACK_WEBHOOK_URL) {
              const errorMessage = {
                text: "Discussionsãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ",
                blocks: [
                  {
                    type: "section",
                    text: {
                      type: "mrkdwn",
                      text: `âŒ Discussionsãƒã‚§ãƒƒã‚¯ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:\n\`\`\`${error.message}\`\`\``
                    }
                  }
                ]
              };

              await fetch(SLACK_WEBHOOK_URL, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(errorMessage)
              });
            }

            throw error;
          }
